<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Shell变量的高级用法（一）——变量替换</title>
    <url>/2022/01/18/Shell%E5%8F%98%E9%87%8F%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95(%E4%B8%80)%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>${变量名#匹配规则}</td>
<td>从变量<code>开头</code>进行规则匹配，将符合最<code>短</code>的数据删除</td>
</tr>
<tr>
<td>${变量名##匹配规则}</td>
<td>从变量<code>开头</code>进行规则匹配，将符合最<code>长</code>的数据删除</td>
</tr>
<tr>
<td>${变量名%匹配规则}</td>
<td>从变量<code>尾部</code>进行规则匹配，将符合最<code>短</code>的数据删除</td>
</tr>
<tr>
<td>${变量名%%匹配规则}</td>
<td>从变量<code>尾部</code>进行规则匹配，将符合最<code>长</code>的数据删除</td>
</tr>
<tr>
<td>${变量名/旧字符串/新字符串}</td>
<td>变量内容符合旧字符串，则<code>第一个</code>旧字符串会被新字符串取代</td>
</tr>
<tr>
<td>${变量名//旧字符串/新字符串}</td>
<td>变量内容符合旧字符串，则<code>全部的</code>旧字符串会被新字符串取代</td>
</tr>
</tbody></table>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>定义一个字符串变量<code>variable</code>，通过不同的替换语法对变量进程替换，并输入结果。</p>
<blockquote>
<p>➜  ~ variable=&quot;I love you, Do you love me?&quot;</p>
</blockquote>
<p>示例1：</p>
<blockquote>
<p>➜  ~ result1=${variable#*ov}<br>➜  ~ echo $result1<br>e you, Do you love me?</p>
</blockquote>
<p>匹配规则为<code>*ov</code>，最短符合匹配规则的字符串为<code>I lov</code>。</p>
<p>示例2：</p>
<blockquote>
<p>➜  ~ result2=${variable##*ov}<br>➜  ~ echo $result2<br>e me?</p>
</blockquote>
<p>匹配规则为<code>*ov</code>，##使用贪婪匹配模式，将匹配到最长符合规则的字符串为<code>I love you, Do you lov</code>。</p>
<p>示例3：</p>
<blockquote>
<p>➜  ~ result3=${variable%ov*}<br>➜  ~ echo $result3<br>I love you, Do you l</p>
</blockquote>
<p>匹配规则为<code>ov*</code>，从后往前最短符合匹配规则的字符串为<code>ov me?</code>。</p>
<p>示例4：</p>
<blockquote>
<p>➜  ~ result4=${variable%ov*}<br>➜  ~ echo $result4<br>I l</p>
</blockquote>
<p>匹配规则为<code>ov*</code>，从后往前最短符合匹配规则的字符串为<code>ove you, Do you lov me?</code>。</p>
<p>示例5：</p>
<blockquote>
<p>➜  ~ result5=${variable/love/LOVE}<br>➜  ~ echo $result5<br>I LOVE you, Do you love me?</p>
</blockquote>
<p>将字符串<code>love</code>替换成大写<code>LOVE</code>，只会替换从开头开始第一个匹配到的<code>love</code>。</p>
<p>示例6：</p>
<blockquote>
<p>➜  ~ result6=${variable//love/LOVE}<br>➜  ~ echo $result6<br>I LOVE you, Do you LOVE me?</p>
</blockquote>
<p>将字符串<code>love</code>替换成大写<code>LOVE</code>，将匹配到的旧字符串<code>love</code>全部替换成新字符串<code>LOVE</code>。</p>
]]></content>
      <categories>
        <category>Shell学习笔记</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell变量的高级用法（三）——字符串处理练习</title>
    <url>/2022/01/18/Shell%E5%8F%98%E9%87%8F%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95(%E4%B8%89)%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>需求描述：<br>变量string=&quot;Bigdata process framework is Hadoop,Hadoop is an open source project&quot;<br>执行脚本后，打印输出string字符串变量，并给出用户一下选项：</p>
<p>(1)、打印string长度<br>(2)、删除字符串中所有的Hadoop<br>(3)、替换第一个Hadoop为Mapreduce<br>(4)、替换全部Hadoop为Mapreduce</p>
<p>用户输入数字1|2|3|4，可以执行对应项的功能；输入q|Q则退出交互模式。</p>
<p>思路分析：<br>1、将不同的功能模块划分，并编写函数<br>function print_tips<br>function len_of_string<br>function del_hadoop<br>function rep_hadoop_mapreduce_first<br>function rep_hadoop_mapreduce_all<br>2、实现第一步所定义的功能函数<br>3、程序主流程的设计</p>
<p>完整脚本代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">string=&quot;Bigdata process framework is Hadoop,Hadoop is an open source project&quot;</span><br><span class="line"></span><br><span class="line">function print_tips &#123;</span><br><span class="line">    echo &quot;****************************************&quot;</span><br><span class="line">    echo &quot;(1)、打印string长度&quot;</span><br><span class="line">    echo &quot;(2)、删除字符串中所有的Hadoop&quot;</span><br><span class="line">    echo &quot;(3)、替换第一个Hadoop为Mapreduce&quot;</span><br><span class="line">    echo &quot;(4)、替换全部Hadoop为Mapreduce&quot;</span><br><span class="line">    echo &quot;****************************************&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function len_of_string &#123;</span><br><span class="line">    echo &quot;$&#123;#string&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function del_hadoop &#123;</span><br><span class="line">    echo &quot;$&#123;string//Hadoop/&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rep_hadoop_mapreduce_first &#123;</span><br><span class="line">    echo &quot;$&#123;string/Hadoop/Mapreduce&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rep_hadoop_mapreduce_all &#123;</span><br><span class="line">    echo &quot;$&#123;string//Hadoop/Mapreduce&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main &#123;</span><br><span class="line">    while true; do</span><br><span class="line">        echo</span><br><span class="line">        echo &quot;【$&#123;string&#125;】&quot;</span><br><span class="line">        echo</span><br><span class="line">        print_tips</span><br><span class="line">        read -p &quot;Please input your choice(1|2|3|4|q|Q):&quot; choice</span><br><span class="line">        case $choice in</span><br><span class="line">            1) len_of_string ;;</span><br><span class="line">            2) del_hadoop ;;</span><br><span class="line">            3) rep_hadoop_mapreduce_first ;;</span><br><span class="line">            4) rep_hadoop_mapreduce_all ;;</span><br><span class="line">            q|Q) exit ;;</span><br><span class="line">            *) echo &quot;Error input&quot;</span><br><span class="line">        esac</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell学习笔记</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell变量的高级用法（二）——字符串处理</title>
    <url>/2022/01/18/Shell%E5%8F%98%E9%87%8F%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95(%E4%BA%8C)%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><table>
<thead>
<tr>
<th></th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>方法一</td>
<td>$&#123;#string&#125;</td>
<td>无</td>
</tr>
<tr>
<td>方法二</td>
<td>expr length &quot;$string&quot;</td>
<td>string有空格，则必须加双引号</td>
</tr>
</tbody></table>
<h1 id="抽取子串"><a href="#抽取子串" class="headerlink" title="抽取子串"></a>抽取子串</h1><table>
<thead>
<tr>
<th></th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>方法一</td>
<td>$&#123;#string:position&#125;</td>
<td>从string中的左边position开始匹配（不包含position）</td>
</tr>
<tr>
<td>方法二</td>
<td>$&#123;#string:(-position)&#125;</td>
<td>从string中的右边position开始匹配（包含position）</td>
</tr>
<tr>
<td>方法三</td>
<td>$&#123;#string:position:length&#125;</td>
<td>从position开始，匹配长度为length</td>
</tr>
<tr>
<td>方法四</td>
<td>expr substr $string $position $length</td>
<td>从position开始，匹配长度为length</td>
</tr>
</tbody></table>
<blockquote>
<p>Tips: 在mac os原生的shell环境中使用expr，会报syntax error错误。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1-计算字符串长度"><a href="#1-计算字符串长度" class="headerlink" title="1.计算字符串长度"></a>1.计算字符串长度</h3><p>方法一：$&#123;#string&#125;<br>例子：</p>
<blockquote>
<p>➜  ~ string=&quot;Hello World&quot;<br>➜  ~ len=$&#123;#string&#125;<br>➜  ~ echo $len<br>11</p>
</blockquote>
<p>方法二：expr length &quot;$string&quot;<br>例子：</p>
<blockquote>
<p>➜  ~ string=&quot;Hello World&quot;<br>➜  ~ len=`expr length &quot;$string&quot;`<br>➜  ~ echo $len<br>11</p>
</blockquote>
<h3 id="2-获取字符串索引位置"><a href="#2-获取字符串索引位置" class="headerlink" title="2.获取字符串索引位置"></a>2.获取字符串索引位置</h3><p>方法：expr index &quot;$string&quot; substr<br>例子：</p>
<blockquote>
<p>string=&quot;Hello World&quot;<br>idx=`expr index &quot;$string&quot; world`</p>
</blockquote>
<p>注意：获取索引会将字匹配的字符串进行字符拆分，根据字符进行匹配。比如：world字符串会被拆成w o r l d进行逐个字符匹配，先匹配到哪个字符就会返回对应索引，并不是真个字符串都匹配上才返回索引。</p>
<h3 id="3-抽取字符串中的子串"><a href="#3-抽取字符串中的子串" class="headerlink" title="3.抽取字符串中的子串"></a>3.抽取字符串中的子串</h3><p>方法一：$&#123;string:position&#125;<br>例子：从string中的左边第2个位置开始匹配。</p>
<blockquote>
<p>➜  ~ string=&quot;1234567890&quot;<br>➜  ~ sub_str=$&#123;string:2&#125;<br>➜  ~ echo $sub_str<br>34567890</p>
</blockquote>
<p>方法二：$&#123;string: -position&#125;<br>例子：从string中的右边第2个位置开始匹配。</p>
<blockquote>
<p>➜  ~ string=&quot;1234567890&quot;<br>➜  ~ sub_str=$&#123;string:(-2)&#125;<br>➜  ~ echo $sub_str<br>90</p>
</blockquote>
<p>注意：$&#123;string:&lt;空格&gt;-position&#125; 或者$&#123;string:(-position)&#125; </p>
<p>方法三：$&#123;string:position:length&#125;<br>例子：从位置2开始，匹配长度为3的子串。</p>
<blockquote>
<p>➜  ~ string=&quot;1234567890&quot;<br>➜  ~ sub_str=$&#123;string:2:3&#125;<br>➜  ~ echo $sub_str<br>345</p>
</blockquote>
<p>注意：使用expr，索引计数是从1开始计算；使用$&#123;string:position&#125;，索引计数是从0开始计算。</p>
]]></content>
      <categories>
        <category>Shell学习笔记</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>深入探索NSMethodSignature和NSInvocation的使用</title>
    <url>/2022/01/19/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2NSMethodSignature%E5%92%8CNSInvocation%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="NSMethodSignature"><a href="#NSMethodSignature" class="headerlink" title="NSMethodSignature"></a>NSMethodSignature</h2><p><strong>NSMethodSignature</strong>主要是方法的返回值和参数的类型信息的记录。</p>
<p>方法签名由方法返回类型的一个或多个字符组成，后跟隐式参数<code>self</code>和<code>_cmd</code>的字符串编码，还有零个或多个显式参数。可以使用<code>methodReturnType</code>和<code>methodReturnLength</code>属性确定字符串编码和返回类型的长度。<code>numberOfArguments</code>属性获取方法参数个数。可以使用<code>getArgumentTypeAtIndex: </code>根据索引获取方法参数。</p>
<p>例如，<strong>NSString</strong>实例方法<code>containsString:</code>有一个带有以下参数的方法签名:<br>@encode(BOOL)  (c)为返回类型<br>@encode(id) (@)为接收者(self)<br>@encode(SEL) (:)为选择器(_cmd)<br>@encode(NSString *) (@)为第一个显式参数</p>
<h2 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h2><p><strong>NSInvocation</strong>对象用于在对象之间存储和转发消息。<strong>NSInvocation</strong>对象包含一个Objective-C消息的所有元素:目标、选择器、参数和返回值。每个元素都可以直接设置，当<strong>NSInvocation</strong>对象被分派时，返回值会自动设置。</p>
<p>一个<strong>NSInvocation</strong>对象可以被重复地分派到不同的目标；它的参数可以修改之间的调度不同的结果；甚至它的选择器也可以更改为具有相同方法签名(参数和返回类型)的另一个选择器。这种灵活性使得<strong>NSInvocation</strong>在使用许多参数和变量重复消息时非常有用；在每次将<strong>NSInvocation</strong>对象发送到一个新目标之前，你可以根据需要修改它，而不是为每个消息重新输入稍微不同的表达式。</p>
<p><strong>NSInvocation</strong>不支持使用可变数量的参数或联合参数的方法调用。创建<strong>NSInvocation</strong>对象应该使用<code>invocationWithMethodSignature:</code>类方法来创建，不应该使用<code>alloc</code>和<code>init</code>创建。</p>
<p>默认情况下，该类不保留包含的调用的参数。如果那些对象可能在你创建<strong>NSInvocation</strong>实例的时间和你使用它的时间之间释放，你应该显式地保留你自己的对象或调用<code>retainArguments</code>方法来让调用对象保留它们自己。</p>
<blockquote>
<p>注意：<br>NSInvocation遵循NSCoding协议，但只支持NSPortCoder编码。NSInvocation不支持归档。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.获取对象方法签名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMethodSignature *signature = [object methodSignatureForSelector:selector];</span><br></pre></td></tr></table></figure>
<p>2.根据方法签名创建<strong>NSInvocation</strong>对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br></pre></td></tr></table></figure>
<p>3.设置执行方法的对象和方法选择器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invocation.target = object;</span><br><span class="line">invocation.selector = selector;</span><br></pre></td></tr></table></figure>

<p>4.设置方法参数。由于前两个参数为隐式self和_cmd，所以需要从第三个参数开始传入显式参数。</p>
<p>入参需要根据参数的类型进行转换后再设置给<strong>invocation</strong>对象。如果不正确根据类型编码设置参数，会导致在方法中无法获取到正确的值。比如传入BOOL值@(YES)，期望接收到的参数为YES，实际为NO（参数默认值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSUInteger paramCount = MIN(signature.numberOfArguments - 2, params.count);</span><br><span class="line">for (int i = 0; i &lt; paramCount; i++) &#123;</span><br><span class="line">    id argument = params[i];</span><br><span class="line">    //获取参数类型编码。如果不正确根据类型编码设置参数，会导致在方法中无法获取到正确的值。比如传入BOOL值@(YES)，期望接收到的参数为YES，实际为NO（参数默认值）</span><br><span class="line">    const char *argumentType = [signature getArgumentTypeAtIndex:i + 2];</span><br><span class="line">    if ([argument isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">        if (!strcmp(argumentType, @encode(BOOL))) &#123;</span><br><span class="line">            BOOL arg = [argument boolValue];</span><br><span class="line">            [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!strcmp(argumentType, @encode(int))) &#123;</span><br><span class="line">            int arg = [argument intValue];</span><br><span class="line">            [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        [invocation setArgument:&amp;argument atIndex:i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>invocation</strong>设置的参数可以比方法的入参个数少，未被赋值的参数变量为默认值。<br>比如：id类型参数默认值为nil，BOOL类型参数默认为NO等等。</p>
<p>5.引用参数并执行方法。invocation默认不会对入参进行引用，为了防止在方法执行完成之前参数被释放，需要手动持有一下参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引用参数，防止在方法执行完成之前参数释放</span><br><span class="line">[invocation retainArguments];</span><br><span class="line">//执行方法</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure>

<p>6.获取返回值并根据返回值类型进行类型转换。因为返回的是c的数据类型void *，所以需要将返回的类型转换成对应的OC对象。<br>更多编码请参见Objective-C运行时编程指南中的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">类型编码</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断是否有返回值</span><br><span class="line">if (signature.methodReturnLength) &#123;</span><br><span class="line">    //获取返回值类型</span><br><span class="line">    const char *returnType = signature.methodReturnType;</span><br><span class="line">    //返回值类型转换</span><br><span class="line">    if (!strcmp(returnType, @encode(void))) &#123;//无返回值</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!strcmp(returnType, @encode(id))) &#123;//对象类型</span><br><span class="line">        void *returnValue;</span><br><span class="line">        [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">        return (__bridge id)returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;//基本数据类型</span><br><span class="line">        void *returnValue = (void *)malloc(signature.methodReturnLength);</span><br><span class="line">        [invocation getReturnValue:returnValue];</span><br><span class="line">        </span><br><span class="line">        id result = nil;</span><br><span class="line">        //根据类型转成NSNumber</span><br><span class="line">        if (!strcmp(returnType, @encode(BOOL))) &#123;</span><br><span class="line">            result = [NSNumber numberWithBool:*((BOOL *)returnValue)];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!strcmp(returnType, @encode(int))) &#123;</span><br><span class="line">            result = [NSNumber numberWithInt:*((int *)returnValue)];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!strcmp(returnType, @encode(short))) &#123;</span><br><span class="line">            result = [NSNumber numberWithShort:*((short *)returnValue)];</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        free(returnValue);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下：<br><strong>HYInjectionCenter.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface HYInjectionCenter : NSObject</span><br><span class="line"></span><br><span class="line">+ (id)invocationMethod:(NSString *)methodName</span><br><span class="line">                object:(id)object</span><br><span class="line">                params:(NSArray *)params;</span><br><span class="line"></span><br><span class="line">+ (id)invocationMethod:(NSString *)methodName</span><br><span class="line">             className:(NSString *)className</span><br><span class="line">                params:(NSArray *)params;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>
<p><strong>HYInjectionCenter.m</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &quot;HYInjectionCenter.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation HYInjectionCenter</span><br><span class="line"></span><br><span class="line">+ (id)invocationMethod:(NSString *)methodName object:(id)object params:(NSArray *)params &#123;</span><br><span class="line">    if (![methodName isKindOfClass:[NSString class]] || methodName.length == 0 || !object) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SEL selector = NSSelectorFromString(methodName);</span><br><span class="line">    //获取对象方法签名</span><br><span class="line">    NSMethodSignature *signature = [object methodSignatureForSelector:selector];</span><br><span class="line">    if (signature) &#123;</span><br><span class="line">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">        invocation.target = object;</span><br><span class="line">        invocation.selector = selector;</span><br><span class="line">        </span><br><span class="line">        //由于前两个参数为隐式self和_cmd，所以需要从第三个参数开始传入显式参数。</span><br><span class="line">        NSUInteger paramCount = MIN(signature.numberOfArguments - 2, params.count);</span><br><span class="line">        for (int i = 0; i &lt; paramCount; i++) &#123;</span><br><span class="line">            id argument = params[i];</span><br><span class="line">            const char *argumentType = [signature getArgumentTypeAtIndex:i + 2];</span><br><span class="line">            if ([argument isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">                if (!strcmp(argumentType, @encode(BOOL))) &#123;</span><br><span class="line">                    BOOL arg = [argument boolValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(int))) &#123;</span><br><span class="line">                    int arg = [argument intValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(short))) &#123;</span><br><span class="line">                    int arg = [argument intValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(long))) &#123;</span><br><span class="line">                    long arg = [argument longValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(long long))) &#123;</span><br><span class="line">                    long long arg = [argument longLongValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(float))) &#123;</span><br><span class="line">                    float arg = [argument floatValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(double))) &#123;</span><br><span class="line">                    double arg = [argument doubleValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(char))) &#123;</span><br><span class="line">                    char arg = [argument charValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(unsigned short))) &#123;</span><br><span class="line">                    unsigned short arg = [argument unsignedShortValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(unsigned int))) &#123;</span><br><span class="line">                    unsigned int arg = [argument unsignedIntValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(unsigned long))) &#123;</span><br><span class="line">                    unsigned long arg = [argument unsignedLongValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(unsigned long long))) &#123;</span><br><span class="line">                    unsigned long long arg = [argument unsignedLongLongValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(argumentType, @encode(unsigned char))) &#123;</span><br><span class="line">                    unsigned char arg = [argument unsignedCharValue];</span><br><span class="line">                    [invocation setArgument:&amp;arg atIndex:i + 2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                [invocation setArgument:&amp;argument atIndex:i + 2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //引用参数，防止在方法执行完成之前参数释放</span><br><span class="line">        [invocation retainArguments];</span><br><span class="line">        //执行方法</span><br><span class="line">        [invocation invoke];</span><br><span class="line">        </span><br><span class="line">        //判断是否有返回值</span><br><span class="line">        if (signature.methodReturnLength) &#123;</span><br><span class="line">            //获取返回值类型</span><br><span class="line">            const char *returnType = signature.methodReturnType;</span><br><span class="line">            //返回值类型转换</span><br><span class="line">            if (!strcmp(returnType, @encode(void))) &#123;//无返回值</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!strcmp(returnType, @encode(id))) &#123;//对象类型</span><br><span class="line">                void *returnValue;</span><br><span class="line">                [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">                return (__bridge id)returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;//基本数据类型</span><br><span class="line">                void *returnValue = (void *)malloc(signature.methodReturnLength);</span><br><span class="line">                [invocation getReturnValue:returnValue];</span><br><span class="line">                </span><br><span class="line">                id result = nil;</span><br><span class="line">                //根据类型转成NSNumber</span><br><span class="line">                if (!strcmp(returnType, @encode(BOOL))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithBool:*((BOOL *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(int))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithInt:*((int *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(short))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithShort:*((short *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(long))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithLong:*((long *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(long long))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithLongLong:*((long long *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(float))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithFloat:*((float *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(double))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithDouble:*((double *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(char))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithChar:*((char *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(unsigned short))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithUnsignedShort:*((unsigned short *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(unsigned int))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithUnsignedInt:*((unsigned int *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(unsigned long))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithUnsignedLong:*((unsigned long *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(unsigned long long))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithUnsignedLongLong:*((unsigned long long *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!strcmp(returnType, @encode(unsigned char))) &#123;</span><br><span class="line">                    result = [NSNumber numberWithUnsignedChar:*((unsigned char *)returnValue)];</span><br><span class="line">                &#125;</span><br><span class="line">                free(returnValue);</span><br><span class="line">                </span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)invocationMethod:(NSString *)methodName className:(NSString *)className params:(NSArray *)params &#123;</span><br><span class="line">    if (![className isKindOfClass:[NSString class]] || className.length == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self invocationMethod:methodName object:NSClassFromString(className) params:params];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>7.测试</p>
<p>创建一个HYManager类，类中包含以下方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface HYManager : NSObject</span><br><span class="line"></span><br><span class="line">- (void)param1:(NSString *)param1 param2:(BOOL)param2 param3:(NSInteger)param3;</span><br><span class="line">- (NSString *)formatWithParam1:(NSString *)param1 param2:(NSInteger)param2;</span><br><span class="line"></span><br><span class="line">- (BOOL)boolTest;</span><br><span class="line">- (CGFloat)CGFloatTest;</span><br><span class="line">- (NSInteger)integerTest;</span><br><span class="line"></span><br><span class="line">+ (void)classFuncTest;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HYManager</span><br><span class="line"></span><br><span class="line">- (void)param1:(NSString *)param1 param2:(BOOL)param2 param3:(NSInteger)param3 &#123;</span><br><span class="line">    NSLog(@&quot;%@ %d %zd&quot;, param1, param2, param3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)formatWithParam1:(NSString *)param1 param2:(NSInteger)param2 &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@-%zd&quot;, param1, param2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)boolTest &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)CGFloatTest &#123;</span><br><span class="line">    return 6.6f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)integerTest &#123;</span><br><span class="line">    return 7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)classFuncTest &#123;</span><br><span class="line">    NSLog(@&quot;class func test&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><strong>用例1</strong>：有入参但无返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HYManager *manager = [[HYManager alloc] init];</span><br><span class="line">[HYInjectionCenter invocationMethod:@&quot;param1:param2:param3:&quot;</span><br><span class="line">                             object:manager</span><br><span class="line">                             params:@[@&quot;hy&quot;, @(YES), @(1)]];</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hy YES 1</span><br></pre></td></tr></table></figure>
<p><strong>用例2</strong>：有入参有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id result = [HYInjectionCenter invocationMethod:@&quot;formatWithParam1:param2:&quot;</span><br><span class="line">                                          object:manager</span><br><span class="line">                                          params:@[@&quot;hy&quot;, @(99)]];</span><br><span class="line">NSLog(@&quot;result: %@&quot;, result);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result: hy-99</span><br></pre></td></tr></table></figure>
<p><strong>用例3</strong>：返回值为基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id boolResult = [HYInjectionCenter invocationMethod:@&quot;boolTest&quot;</span><br><span class="line">                                             object:manager</span><br><span class="line">                                             params:nil];</span><br><span class="line">id CGFloatResult = [HYInjectionCenter invocationMethod:@&quot;CGFloatTest&quot;</span><br><span class="line">                                            object:manager</span><br><span class="line">                                            params:nil];</span><br><span class="line">id integerResult = [HYInjectionCenter invocationMethod:@&quot;integerTest&quot;</span><br><span class="line">                                            object:manager</span><br><span class="line">                                            params:nil];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;boolResult:%@&quot;, [boolResult boolValue] ? @&quot;YES&quot; : @&quot;NO&quot;);</span><br><span class="line">NSLog(@&quot;CGFloatResult:%f &quot;, [CGFloatResult floatValue]);</span><br><span class="line">NSLog(@&quot;integerResult:%zd&quot;, [integerResult integerValue]);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolResult:YES</span><br><span class="line">CGFloatResult:6.600000</span><br><span class="line">integerResult:7</span><br></pre></td></tr></table></figure>
<p><strong>用例4</strong>：类方法调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[HYInjectionCenter invocationMethod:@&quot;classFuncTest&quot;</span><br><span class="line">                          className:@&quot;HYManager&quot;</span><br><span class="line">                             params:nil];</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class func test</span><br></pre></td></tr></table></figure>
<p><strong>用例5</strong>：传入参数小于方法参数个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[HYInjectionCenter invocationMethod:@&quot;param1:param2:param3&quot;</span><br><span class="line">                             object:manager</span><br><span class="line">                             params:@[]];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(null) NO 0</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果未按入参类型编码判断类型并转换之后赋值，则无法正确获取参数。比如之前按以下的方式直接设置参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSUInteger paramCount = MIN(signature.numberOfArguments - 2, params.count);</span><br><span class="line">for (int i = 0; i &lt; paramCount; i++) &#123;</span><br><span class="line">    id argument = params[i];</span><br><span class="line">    [invocation setArgument:&amp;argument atIndex:i + 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行用例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HYManager *manager = [[HYManager alloc] init];</span><br><span class="line">[HYInjectionCenter invocationMethod:@&quot;param1:param2:param3:&quot;</span><br><span class="line">                             object:manager</span><br><span class="line">                             params:@[@&quot;hy&quot;, @(YES), @(1)]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hy NO -2366665138710127672</span><br></pre></td></tr></table></figure>
<p>可以看出，并非输出预期的结果。所以即便繁琐，也需要一一进行参数类型转换。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
